// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_ATTACK;
struct C_ATTACKDefaultTypeInternal;
extern C_ATTACKDefaultTypeInternal _C_ATTACK_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_CLICKNPC;
struct C_CLICKNPCDefaultTypeInternal;
extern C_CLICKNPCDefaultTypeInternal _C_CLICKNPC_default_instance_;
class C_CREATECHARACTER;
struct C_CREATECHARACTERDefaultTypeInternal;
extern C_CREATECHARACTERDefaultTypeInternal _C_CREATECHARACTER_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_GETITEM;
struct C_GETITEMDefaultTypeInternal;
extern C_GETITEMDefaultTypeInternal _C_GETITEM_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_PURCHASE;
struct C_PURCHASEDefaultTypeInternal;
extern C_PURCHASEDefaultTypeInternal _C_PURCHASE_default_instance_;
class C_RESPAWN;
struct C_RESPAWNDefaultTypeInternal;
extern C_RESPAWNDefaultTypeInternal _C_RESPAWN_default_instance_;
class C_SALE;
struct C_SALEDefaultTypeInternal;
extern C_SALEDefaultTypeInternal _C_SALE_default_instance_;
class C_SIGNUP;
struct C_SIGNUPDefaultTypeInternal;
extern C_SIGNUPDefaultTypeInternal _C_SIGNUP_default_instance_;
class C_STAT;
struct C_STATDefaultTypeInternal;
extern C_STATDefaultTypeInternal _C_STAT_default_instance_;
class C_SWAP_ITEM;
struct C_SWAP_ITEMDefaultTypeInternal;
extern C_SWAP_ITEMDefaultTypeInternal _C_SWAP_ITEM_default_instance_;
class C_UNEQUIP;
struct C_UNEQUIPDefaultTypeInternal;
extern C_UNEQUIPDefaultTypeInternal _C_UNEQUIP_default_instance_;
class C_USE_ITEM;
struct C_USE_ITEMDefaultTypeInternal;
extern C_USE_ITEMDefaultTypeInternal _C_USE_ITEM_default_instance_;
class S_ATTACK;
struct S_ATTACKDefaultTypeInternal;
extern S_ATTACKDefaultTypeInternal _S_ATTACK_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_CLICKNPC;
struct S_CLICKNPCDefaultTypeInternal;
extern S_CLICKNPCDefaultTypeInternal _S_CLICKNPC_default_instance_;
class S_DEAD;
struct S_DEADDefaultTypeInternal;
extern S_DEADDefaultTypeInternal _S_DEAD_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_EXP;
struct S_EXPDefaultTypeInternal;
extern S_EXPDefaultTypeInternal _S_EXP_default_instance_;
class S_GETITEM;
struct S_GETITEMDefaultTypeInternal;
extern S_GETITEMDefaultTypeInternal _S_GETITEM_default_instance_;
class S_LEAVE;
struct S_LEAVEDefaultTypeInternal;
extern S_LEAVEDefaultTypeInternal _S_LEAVE_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_PURCHASE;
struct S_PURCHASEDefaultTypeInternal;
extern S_PURCHASEDefaultTypeInternal _S_PURCHASE_default_instance_;
class S_RESPAWN;
struct S_RESPAWNDefaultTypeInternal;
extern S_RESPAWNDefaultTypeInternal _S_RESPAWN_default_instance_;
class S_SALE;
struct S_SALEDefaultTypeInternal;
extern S_SALEDefaultTypeInternal _S_SALE_default_instance_;
class S_SERVERCONNECT;
struct S_SERVERCONNECTDefaultTypeInternal;
extern S_SERVERCONNECTDefaultTypeInternal _S_SERVERCONNECT_default_instance_;
class S_SIGNUP;
struct S_SIGNUPDefaultTypeInternal;
extern S_SIGNUPDefaultTypeInternal _S_SIGNUP_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_STAT;
struct S_STATDefaultTypeInternal;
extern S_STATDefaultTypeInternal _S_STAT_default_instance_;
class S_STATE;
struct S_STATEDefaultTypeInternal;
extern S_STATEDefaultTypeInternal _S_STATE_default_instance_;
class S_SWAP_ITEM;
struct S_SWAP_ITEMDefaultTypeInternal;
extern S_SWAP_ITEMDefaultTypeInternal _S_SWAP_ITEM_default_instance_;
class S_UNEQUIP;
struct S_UNEQUIPDefaultTypeInternal;
extern S_UNEQUIPDefaultTypeInternal _S_UNEQUIP_default_instance_;
class S_USE_ITEM;
struct S_USE_ITEMDefaultTypeInternal;
extern S_USE_ITEMDefaultTypeInternal _S_USE_ITEM_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_ATTACK* Arena::CreateMaybeMessage<::Protocol::C_ATTACK>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_CLICKNPC* Arena::CreateMaybeMessage<::Protocol::C_CLICKNPC>(Arena*);
template<> ::Protocol::C_CREATECHARACTER* Arena::CreateMaybeMessage<::Protocol::C_CREATECHARACTER>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_GETITEM* Arena::CreateMaybeMessage<::Protocol::C_GETITEM>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_PURCHASE* Arena::CreateMaybeMessage<::Protocol::C_PURCHASE>(Arena*);
template<> ::Protocol::C_RESPAWN* Arena::CreateMaybeMessage<::Protocol::C_RESPAWN>(Arena*);
template<> ::Protocol::C_SALE* Arena::CreateMaybeMessage<::Protocol::C_SALE>(Arena*);
template<> ::Protocol::C_SIGNUP* Arena::CreateMaybeMessage<::Protocol::C_SIGNUP>(Arena*);
template<> ::Protocol::C_STAT* Arena::CreateMaybeMessage<::Protocol::C_STAT>(Arena*);
template<> ::Protocol::C_SWAP_ITEM* Arena::CreateMaybeMessage<::Protocol::C_SWAP_ITEM>(Arena*);
template<> ::Protocol::C_UNEQUIP* Arena::CreateMaybeMessage<::Protocol::C_UNEQUIP>(Arena*);
template<> ::Protocol::C_USE_ITEM* Arena::CreateMaybeMessage<::Protocol::C_USE_ITEM>(Arena*);
template<> ::Protocol::S_ATTACK* Arena::CreateMaybeMessage<::Protocol::S_ATTACK>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_CLICKNPC* Arena::CreateMaybeMessage<::Protocol::S_CLICKNPC>(Arena*);
template<> ::Protocol::S_DEAD* Arena::CreateMaybeMessage<::Protocol::S_DEAD>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_EXP* Arena::CreateMaybeMessage<::Protocol::S_EXP>(Arena*);
template<> ::Protocol::S_GETITEM* Arena::CreateMaybeMessage<::Protocol::S_GETITEM>(Arena*);
template<> ::Protocol::S_LEAVE* Arena::CreateMaybeMessage<::Protocol::S_LEAVE>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_PURCHASE* Arena::CreateMaybeMessage<::Protocol::S_PURCHASE>(Arena*);
template<> ::Protocol::S_RESPAWN* Arena::CreateMaybeMessage<::Protocol::S_RESPAWN>(Arena*);
template<> ::Protocol::S_SALE* Arena::CreateMaybeMessage<::Protocol::S_SALE>(Arena*);
template<> ::Protocol::S_SERVERCONNECT* Arena::CreateMaybeMessage<::Protocol::S_SERVERCONNECT>(Arena*);
template<> ::Protocol::S_SIGNUP* Arena::CreateMaybeMessage<::Protocol::S_SIGNUP>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_STAT* Arena::CreateMaybeMessage<::Protocol::S_STAT>(Arena*);
template<> ::Protocol::S_STATE* Arena::CreateMaybeMessage<::Protocol::S_STATE>(Arena*);
template<> ::Protocol::S_SWAP_ITEM* Arena::CreateMaybeMessage<::Protocol::S_SWAP_ITEM>(Arena*);
template<> ::Protocol::S_UNEQUIP* Arena::CreateMaybeMessage<::Protocol::S_UNEQUIP>(Arena*);
template<> ::Protocol::S_USE_ITEM* Arena::CreateMaybeMessage<::Protocol::S_USE_ITEM>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class S_SERVERCONNECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SERVERCONNECT) */ {
 public:
  inline S_SERVERCONNECT() : S_SERVERCONNECT(nullptr) {}
  ~S_SERVERCONNECT() override;
  explicit constexpr S_SERVERCONNECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SERVERCONNECT(const S_SERVERCONNECT& from);
  S_SERVERCONNECT(S_SERVERCONNECT&& from) noexcept
    : S_SERVERCONNECT() {
    *this = ::std::move(from);
  }

  inline S_SERVERCONNECT& operator=(const S_SERVERCONNECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SERVERCONNECT& operator=(S_SERVERCONNECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SERVERCONNECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SERVERCONNECT* internal_default_instance() {
    return reinterpret_cast<const S_SERVERCONNECT*>(
               &_S_SERVERCONNECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_SERVERCONNECT& a, S_SERVERCONNECT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SERVERCONNECT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SERVERCONNECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_SERVERCONNECT* New() const final {
    return new S_SERVERCONNECT();
  }

  S_SERVERCONNECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_SERVERCONNECT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_SERVERCONNECT& from);
  void MergeFrom(const S_SERVERCONNECT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SERVERCONNECT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SERVERCONNECT";
  }
  protected:
  explicit S_SERVERCONNECT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SERVERCONNECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SIGNUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SIGNUP) */ {
 public:
  inline C_SIGNUP() : C_SIGNUP(nullptr) {}
  ~C_SIGNUP() override;
  explicit constexpr C_SIGNUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SIGNUP(const C_SIGNUP& from);
  C_SIGNUP(C_SIGNUP&& from) noexcept
    : C_SIGNUP() {
    *this = ::std::move(from);
  }

  inline C_SIGNUP& operator=(const C_SIGNUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SIGNUP& operator=(C_SIGNUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SIGNUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SIGNUP* internal_default_instance() {
    return reinterpret_cast<const C_SIGNUP*>(
               &_C_SIGNUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(C_SIGNUP& a, C_SIGNUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SIGNUP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SIGNUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_SIGNUP* New() const final {
    return new C_SIGNUP();
  }

  C_SIGNUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_SIGNUP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_SIGNUP& from);
  void MergeFrom(const C_SIGNUP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SIGNUP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SIGNUP";
  }
  protected:
  explicit C_SIGNUP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SIGNUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SIGNUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SIGNUP) */ {
 public:
  inline S_SIGNUP() : S_SIGNUP(nullptr) {}
  ~S_SIGNUP() override;
  explicit constexpr S_SIGNUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SIGNUP(const S_SIGNUP& from);
  S_SIGNUP(S_SIGNUP&& from) noexcept
    : S_SIGNUP() {
    *this = ::std::move(from);
  }

  inline S_SIGNUP& operator=(const S_SIGNUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SIGNUP& operator=(S_SIGNUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SIGNUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SIGNUP* internal_default_instance() {
    return reinterpret_cast<const S_SIGNUP*>(
               &_S_SIGNUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_SIGNUP& a, S_SIGNUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SIGNUP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SIGNUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_SIGNUP* New() const final {
    return new S_SIGNUP();
  }

  S_SIGNUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_SIGNUP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_SIGNUP& from);
  void MergeFrom(const S_SIGNUP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SIGNUP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SIGNUP";
  }
  protected:
  explicit S_SIGNUP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SIGNUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit constexpr C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_LOGIN* New() const final {
    return new C_LOGIN();
  }

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_LOGIN& from);
  void MergeFrom(const C_LOGIN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit constexpr S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_LOGIN* New() const final {
    return new S_LOGIN();
  }

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_LOGIN& from);
  void MergeFrom(const S_LOGIN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CREATECHARACTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CREATECHARACTER) */ {
 public:
  inline C_CREATECHARACTER() : C_CREATECHARACTER(nullptr) {}
  ~C_CREATECHARACTER() override;
  explicit constexpr C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATECHARACTER(const C_CREATECHARACTER& from);
  C_CREATECHARACTER(C_CREATECHARACTER&& from) noexcept
    : C_CREATECHARACTER() {
    *this = ::std::move(from);
  }

  inline C_CREATECHARACTER& operator=(const C_CREATECHARACTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATECHARACTER& operator=(C_CREATECHARACTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATECHARACTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATECHARACTER* internal_default_instance() {
    return reinterpret_cast<const C_CREATECHARACTER*>(
               &_C_CREATECHARACTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_CREATECHARACTER& a, C_CREATECHARACTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATECHARACTER* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATECHARACTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_CREATECHARACTER* New() const final {
    return new C_CREATECHARACTER();
  }

  C_CREATECHARACTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_CREATECHARACTER>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_CREATECHARACTER& from);
  void MergeFrom(const C_CREATECHARACTER& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATECHARACTER* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATECHARACTER";
  }
  protected:
  explicit C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .Protocol.PlayerType type = 1;
  void clear_type();
  ::Protocol::PlayerType type() const;
  void set_type(::Protocol::PlayerType value);
  private:
  ::Protocol::PlayerType _internal_type() const;
  void _internal_set_type(::Protocol::PlayerType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATECHARACTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit constexpr C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_ENTER_GAME* New() const final {
    return new C_ENTER_GAME();
  }

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_ENTER_GAME& from);
  void MergeFrom(const C_ENTER_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit constexpr S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ENTER_GAME* New() const final {
    return new S_ENTER_GAME();
  }

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ENTER_GAME& from);
  void MergeFrom(const S_ENTER_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvenFieldNumber = 4,
    kEquipFieldNumber = 5,
    kCharacterInfoFieldNumber = 3,
    kMapidFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated .Protocol.PBItemData inven = 4;
  int inven_size() const;
  private:
  int _internal_inven_size() const;
  public:
  void clear_inven();
  ::Protocol::PBItemData* mutable_inven(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
      mutable_inven();
  private:
  const ::Protocol::PBItemData& _internal_inven(int index) const;
  ::Protocol::PBItemData* _internal_add_inven();
  public:
  const ::Protocol::PBItemData& inven(int index) const;
  ::Protocol::PBItemData* add_inven();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
      inven() const;

  // repeated .Protocol.PBItemData equip = 5;
  int equip_size() const;
  private:
  int _internal_equip_size() const;
  public:
  void clear_equip();
  ::Protocol::PBItemData* mutable_equip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
      mutable_equip();
  private:
  const ::Protocol::PBItemData& _internal_equip(int index) const;
  ::Protocol::PBItemData* _internal_add_equip();
  public:
  const ::Protocol::PBItemData& equip(int index) const;
  ::Protocol::PBItemData* add_equip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
      equip() const;

  // .Protocol.PBCharacterData characterInfo = 3;
  bool has_characterinfo() const;
  private:
  bool _internal_has_characterinfo() const;
  public:
  void clear_characterinfo();
  const ::Protocol::PBCharacterData& characterinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBCharacterData* release_characterinfo();
  ::Protocol::PBCharacterData* mutable_characterinfo();
  void set_allocated_characterinfo(::Protocol::PBCharacterData* characterinfo);
  private:
  const ::Protocol::PBCharacterData& _internal_characterinfo() const;
  ::Protocol::PBCharacterData* _internal_mutable_characterinfo();
  public:
  void unsafe_arena_set_allocated_characterinfo(
      ::Protocol::PBCharacterData* characterinfo);
  ::Protocol::PBCharacterData* unsafe_arena_release_characterinfo();

  // uint64 mapid = 1;
  void clear_mapid();
  ::PROTOBUF_NAMESPACE_ID::uint64 mapid() const;
  void set_mapid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_mapid() const;
  void _internal_set_mapid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData > inven_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData > equip_;
  ::Protocol::PBCharacterData* characterinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 mapid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit constexpr S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_SPAWN* New() const final {
    return new S_SPAWN();
  }

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_SPAWN& from);
  void MergeFrom(const S_SPAWN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfosFieldNumber = 2,
    kInvenFieldNumber = 4,
    kEquipFieldNumber = 5,
    kCharacterInfoFieldNumber = 3,
    kIsmyFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objectInfos = 2;
  int objectinfos_size() const;
  private:
  int _internal_objectinfos_size() const;
  public:
  void clear_objectinfos();
  ::Protocol::ObjectInfo* mutable_objectinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objectinfos();
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfos(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objectinfos();
  public:
  const ::Protocol::ObjectInfo& objectinfos(int index) const;
  ::Protocol::ObjectInfo* add_objectinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objectinfos() const;

  // repeated .Protocol.PBItemData inven = 4;
  int inven_size() const;
  private:
  int _internal_inven_size() const;
  public:
  void clear_inven();
  ::Protocol::PBItemData* mutable_inven(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
      mutable_inven();
  private:
  const ::Protocol::PBItemData& _internal_inven(int index) const;
  ::Protocol::PBItemData* _internal_add_inven();
  public:
  const ::Protocol::PBItemData& inven(int index) const;
  ::Protocol::PBItemData* add_inven();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
      inven() const;

  // repeated .Protocol.PBItemData equip = 5;
  int equip_size() const;
  private:
  int _internal_equip_size() const;
  public:
  void clear_equip();
  ::Protocol::PBItemData* mutable_equip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
      mutable_equip();
  private:
  const ::Protocol::PBItemData& _internal_equip(int index) const;
  ::Protocol::PBItemData* _internal_add_equip();
  public:
  const ::Protocol::PBItemData& equip(int index) const;
  ::Protocol::PBItemData* add_equip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
      equip() const;

  // .Protocol.PBCharacterData characterInfo = 3;
  bool has_characterinfo() const;
  private:
  bool _internal_has_characterinfo() const;
  public:
  void clear_characterinfo();
  const ::Protocol::PBCharacterData& characterinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBCharacterData* release_characterinfo();
  ::Protocol::PBCharacterData* mutable_characterinfo();
  void set_allocated_characterinfo(::Protocol::PBCharacterData* characterinfo);
  private:
  const ::Protocol::PBCharacterData& _internal_characterinfo() const;
  ::Protocol::PBCharacterData* _internal_mutable_characterinfo();
  public:
  void unsafe_arena_set_allocated_characterinfo(
      ::Protocol::PBCharacterData* characterinfo);
  ::Protocol::PBCharacterData* unsafe_arena_release_characterinfo();

  // bool ismy = 1;
  void clear_ismy();
  bool ismy() const;
  void set_ismy(bool value);
  private:
  bool _internal_ismy() const;
  void _internal_set_ismy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objectinfos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData > inven_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData > equip_;
  ::Protocol::PBCharacterData* characterinfo_;
  bool ismy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE) */ {
 public:
  inline S_LEAVE() : S_LEAVE(nullptr) {}
  ~S_LEAVE() override;
  explicit constexpr S_LEAVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE(const S_LEAVE& from);
  S_LEAVE(S_LEAVE&& from) noexcept
    : S_LEAVE() {
    *this = ::std::move(from);
  }

  inline S_LEAVE& operator=(const S_LEAVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE& operator=(S_LEAVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE*>(
               &_S_LEAVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_LEAVE& a, S_LEAVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_LEAVE* New() const final {
    return new S_LEAVE();
  }

  S_LEAVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_LEAVE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_LEAVE& from);
  void MergeFrom(const S_LEAVE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEAVE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE";
  }
  protected:
  explicit S_LEAVE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit constexpr C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_MOVE* New() const final {
    return new C_MOVE();
  }

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_MOVE& from);
  void MergeFrom(const C_MOVE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit constexpr S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_MOVE* New() const final {
    return new S_MOVE();
  }

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_MOVE& from);
  void MergeFrom(const S_MOVE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
    kMoveLocationFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // .Protocol.PBVector MoveLocation = 3;
  bool has_movelocation() const;
  private:
  bool _internal_has_movelocation() const;
  public:
  void clear_movelocation();
  const ::Protocol::PBVector& movelocation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBVector* release_movelocation();
  ::Protocol::PBVector* mutable_movelocation();
  void set_allocated_movelocation(::Protocol::PBVector* movelocation);
  private:
  const ::Protocol::PBVector& _internal_movelocation() const;
  ::Protocol::PBVector* _internal_mutable_movelocation();
  public:
  void unsafe_arena_set_allocated_movelocation(
      ::Protocol::PBVector* movelocation);
  ::Protocol::PBVector* unsafe_arena_release_movelocation();

  // .Protocol.StateType state = 2;
  void clear_state();
  ::Protocol::StateType state() const;
  void set_state(::Protocol::StateType value);
  private:
  ::Protocol::StateType _internal_state() const;
  void _internal_set_state(::Protocol::StateType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  ::Protocol::PBVector* movelocation_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ATTACK) */ {
 public:
  inline C_ATTACK() : C_ATTACK(nullptr) {}
  ~C_ATTACK() override;
  explicit constexpr C_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ATTACK(const C_ATTACK& from);
  C_ATTACK(C_ATTACK&& from) noexcept
    : C_ATTACK() {
    *this = ::std::move(from);
  }

  inline C_ATTACK& operator=(const C_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ATTACK& operator=(C_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ATTACK* internal_default_instance() {
    return reinterpret_cast<const C_ATTACK*>(
               &_C_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_ATTACK& a, C_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ATTACK* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_ATTACK* New() const final {
    return new C_ATTACK();
  }

  C_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_ATTACK>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_ATTACK& from);
  void MergeFrom(const C_ATTACK& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ATTACK* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ATTACK";
  }
  protected:
  explicit C_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
    kAttackIdFieldNumber = 2,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // uint32 attackId = 2;
  void clear_attackid();
  ::PROTOBUF_NAMESPACE_ID::uint32 attackid() const;
  void set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_attackid() const;
  void _internal_set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attackid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ATTACK) */ {
 public:
  inline S_ATTACK() : S_ATTACK(nullptr) {}
  ~S_ATTACK() override;
  explicit constexpr S_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ATTACK(const S_ATTACK& from);
  S_ATTACK(S_ATTACK&& from) noexcept
    : S_ATTACK() {
    *this = ::std::move(from);
  }

  inline S_ATTACK& operator=(const S_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ATTACK& operator=(S_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ATTACK* internal_default_instance() {
    return reinterpret_cast<const S_ATTACK*>(
               &_S_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_ATTACK& a, S_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ATTACK* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ATTACK* New() const final {
    return new S_ATTACK();
  }

  S_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ATTACK>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ATTACK& from);
  void MergeFrom(const S_ATTACK& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ATTACK* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ATTACK";
  }
  protected:
  explicit S_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
    kAttackIdFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // uint32 attackId = 2;
  void clear_attackid();
  ::PROTOBUF_NAMESPACE_ID::uint32 attackid() const;
  void set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_attackid() const;
  void _internal_set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Protocol.StateType state = 3;
  void clear_state();
  ::Protocol::StateType state() const;
  void set_state(::Protocol::StateType value);
  private:
  ::Protocol::StateType _internal_state() const;
  void _internal_set_state(::Protocol::StateType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attackid_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_STATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_STATE) */ {
 public:
  inline S_STATE() : S_STATE(nullptr) {}
  ~S_STATE() override;
  explicit constexpr S_STATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_STATE(const S_STATE& from);
  S_STATE(S_STATE&& from) noexcept
    : S_STATE() {
    *this = ::std::move(from);
  }

  inline S_STATE& operator=(const S_STATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_STATE& operator=(S_STATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_STATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_STATE* internal_default_instance() {
    return reinterpret_cast<const S_STATE*>(
               &_S_STATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_STATE& a, S_STATE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_STATE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_STATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_STATE* New() const final {
    return new S_STATE();
  }

  S_STATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_STATE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_STATE& from);
  void MergeFrom(const S_STATE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_STATE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_STATE";
  }
  protected:
  explicit S_STATE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
    kStateFieldNumber = 2,
    kSkillidFieldNumber = 3,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // .Protocol.StateType state = 2;
  void clear_state();
  ::Protocol::StateType state() const;
  void set_state(::Protocol::StateType value);
  private:
  ::Protocol::StateType _internal_state() const;
  void _internal_set_state(::Protocol::StateType value);
  public:

  // uint32 skillid = 3;
  void clear_skillid();
  ::PROTOBUF_NAMESPACE_ID::uint32 skillid() const;
  void set_skillid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_skillid() const;
  void _internal_set_skillid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_STATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skillid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit constexpr C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_CHAT* New() const final {
    return new C_CHAT();
  }

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_CHAT& from);
  void MergeFrom(const C_CHAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit constexpr S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_CHAT* New() const final {
    return new S_CHAT();
  }

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_CHAT& from);
  void MergeFrom(const S_CHAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_GETITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_GETITEM) */ {
 public:
  inline C_GETITEM() : C_GETITEM(nullptr) {}
  ~C_GETITEM() override;
  explicit constexpr C_GETITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GETITEM(const C_GETITEM& from);
  C_GETITEM(C_GETITEM&& from) noexcept
    : C_GETITEM() {
    *this = ::std::move(from);
  }

  inline C_GETITEM& operator=(const C_GETITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GETITEM& operator=(C_GETITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GETITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GETITEM* internal_default_instance() {
    return reinterpret_cast<const C_GETITEM*>(
               &_C_GETITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_GETITEM& a, C_GETITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GETITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GETITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_GETITEM* New() const final {
    return new C_GETITEM();
  }

  C_GETITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_GETITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_GETITEM& from);
  void MergeFrom(const C_GETITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_GETITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GETITEM";
  }
  protected:
  explicit C_GETITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_GETITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GETITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GETITEM) */ {
 public:
  inline S_GETITEM() : S_GETITEM(nullptr) {}
  ~S_GETITEM() override;
  explicit constexpr S_GETITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GETITEM(const S_GETITEM& from);
  S_GETITEM(S_GETITEM&& from) noexcept
    : S_GETITEM() {
    *this = ::std::move(from);
  }

  inline S_GETITEM& operator=(const S_GETITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GETITEM& operator=(S_GETITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GETITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GETITEM* internal_default_instance() {
    return reinterpret_cast<const S_GETITEM*>(
               &_S_GETITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_GETITEM& a, S_GETITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GETITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GETITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_GETITEM* New() const final {
    return new S_GETITEM();
  }

  S_GETITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_GETITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_GETITEM& from);
  void MergeFrom(const S_GETITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GETITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GETITEM";
  }
  protected:
  explicit S_GETITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kIdxFieldNumber = 2,
  };
  // .Protocol.PBItemData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::Protocol::PBItemData& data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBItemData* release_data();
  ::Protocol::PBItemData* mutable_data();
  void set_allocated_data(::Protocol::PBItemData* data);
  private:
  const ::Protocol::PBItemData& _internal_data() const;
  ::Protocol::PBItemData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::Protocol::PBItemData* data);
  ::Protocol::PBItemData* unsafe_arena_release_data();

  // uint32 idx = 2;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_GETITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PBItemData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CLICKNPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CLICKNPC) */ {
 public:
  inline C_CLICKNPC() : C_CLICKNPC(nullptr) {}
  ~C_CLICKNPC() override;
  explicit constexpr C_CLICKNPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CLICKNPC(const C_CLICKNPC& from);
  C_CLICKNPC(C_CLICKNPC&& from) noexcept
    : C_CLICKNPC() {
    *this = ::std::move(from);
  }

  inline C_CLICKNPC& operator=(const C_CLICKNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CLICKNPC& operator=(C_CLICKNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CLICKNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CLICKNPC* internal_default_instance() {
    return reinterpret_cast<const C_CLICKNPC*>(
               &_C_CLICKNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_CLICKNPC& a, C_CLICKNPC& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CLICKNPC* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CLICKNPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_CLICKNPC* New() const final {
    return new C_CLICKNPC();
  }

  C_CLICKNPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_CLICKNPC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_CLICKNPC& from);
  void MergeFrom(const C_CLICKNPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CLICKNPC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CLICKNPC";
  }
  protected:
  explicit C_CLICKNPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CLICKNPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CLICKNPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CLICKNPC) */ {
 public:
  inline S_CLICKNPC() : S_CLICKNPC(nullptr) {}
  ~S_CLICKNPC() override;
  explicit constexpr S_CLICKNPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CLICKNPC(const S_CLICKNPC& from);
  S_CLICKNPC(S_CLICKNPC&& from) noexcept
    : S_CLICKNPC() {
    *this = ::std::move(from);
  }

  inline S_CLICKNPC& operator=(const S_CLICKNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CLICKNPC& operator=(S_CLICKNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CLICKNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CLICKNPC* internal_default_instance() {
    return reinterpret_cast<const S_CLICKNPC*>(
               &_S_CLICKNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_CLICKNPC& a, S_CLICKNPC& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CLICKNPC* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CLICKNPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_CLICKNPC* New() const final {
    return new S_CLICKNPC();
  }

  S_CLICKNPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_CLICKNPC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_CLICKNPC& from);
  void MergeFrom(const S_CLICKNPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CLICKNPC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CLICKNPC";
  }
  protected:
  explicit S_CLICKNPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated uint32 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_ids() const;
  void _internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 ids(int index) const;
  void set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_CLICKNPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > ids_;
  mutable std::atomic<int> _ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PURCHASE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PURCHASE) */ {
 public:
  inline C_PURCHASE() : C_PURCHASE(nullptr) {}
  ~C_PURCHASE() override;
  explicit constexpr C_PURCHASE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PURCHASE(const C_PURCHASE& from);
  C_PURCHASE(C_PURCHASE&& from) noexcept
    : C_PURCHASE() {
    *this = ::std::move(from);
  }

  inline C_PURCHASE& operator=(const C_PURCHASE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PURCHASE& operator=(C_PURCHASE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PURCHASE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PURCHASE* internal_default_instance() {
    return reinterpret_cast<const C_PURCHASE*>(
               &_C_PURCHASE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_PURCHASE& a, C_PURCHASE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PURCHASE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PURCHASE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_PURCHASE* New() const final {
    return new C_PURCHASE();
  }

  C_PURCHASE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_PURCHASE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_PURCHASE& from);
  void MergeFrom(const C_PURCHASE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PURCHASE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PURCHASE";
  }
  protected:
  explicit C_PURCHASE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCntFieldNumber = 2,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 cnt = 2;
  void clear_cnt();
  ::PROTOBUF_NAMESPACE_ID::uint32 cnt() const;
  void set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cnt() const;
  void _internal_set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PURCHASE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cnt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PURCHASE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PURCHASE) */ {
 public:
  inline S_PURCHASE() : S_PURCHASE(nullptr) {}
  ~S_PURCHASE() override;
  explicit constexpr S_PURCHASE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PURCHASE(const S_PURCHASE& from);
  S_PURCHASE(S_PURCHASE&& from) noexcept
    : S_PURCHASE() {
    *this = ::std::move(from);
  }

  inline S_PURCHASE& operator=(const S_PURCHASE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PURCHASE& operator=(S_PURCHASE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PURCHASE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PURCHASE* internal_default_instance() {
    return reinterpret_cast<const S_PURCHASE*>(
               &_S_PURCHASE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_PURCHASE& a, S_PURCHASE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PURCHASE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PURCHASE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_PURCHASE* New() const final {
    return new S_PURCHASE();
  }

  S_PURCHASE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_PURCHASE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_PURCHASE& from);
  void MergeFrom(const S_PURCHASE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PURCHASE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PURCHASE";
  }
  protected:
  explicit S_PURCHASE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kIdxFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // .Protocol.PBItemData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::Protocol::PBItemData& data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBItemData* release_data();
  ::Protocol::PBItemData* mutable_data();
  void set_allocated_data(::Protocol::PBItemData* data);
  private:
  const ::Protocol::PBItemData& _internal_data() const;
  ::Protocol::PBItemData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::Protocol::PBItemData* data);
  ::Protocol::PBItemData* unsafe_arena_release_data();

  // uint32 idx = 2;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::uint32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PURCHASE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PBItemData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SALE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SALE) */ {
 public:
  inline C_SALE() : C_SALE(nullptr) {}
  ~C_SALE() override;
  explicit constexpr C_SALE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SALE(const C_SALE& from);
  C_SALE(C_SALE&& from) noexcept
    : C_SALE() {
    *this = ::std::move(from);
  }

  inline C_SALE& operator=(const C_SALE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SALE& operator=(C_SALE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SALE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SALE* internal_default_instance() {
    return reinterpret_cast<const C_SALE*>(
               &_C_SALE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_SALE& a, C_SALE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SALE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SALE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_SALE* New() const final {
    return new C_SALE();
  }

  C_SALE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_SALE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_SALE& from);
  void MergeFrom(const C_SALE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SALE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SALE";
  }
  protected:
  explicit C_SALE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
    kCntFieldNumber = 2,
  };
  // uint32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 cnt = 2;
  void clear_cnt();
  ::PROTOBUF_NAMESPACE_ID::uint32 cnt() const;
  void set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cnt() const;
  void _internal_set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SALE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cnt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SALE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SALE) */ {
 public:
  inline S_SALE() : S_SALE(nullptr) {}
  ~S_SALE() override;
  explicit constexpr S_SALE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SALE(const S_SALE& from);
  S_SALE(S_SALE&& from) noexcept
    : S_SALE() {
    *this = ::std::move(from);
  }

  inline S_SALE& operator=(const S_SALE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SALE& operator=(S_SALE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SALE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SALE* internal_default_instance() {
    return reinterpret_cast<const S_SALE*>(
               &_S_SALE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_SALE& a, S_SALE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SALE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SALE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_SALE* New() const final {
    return new S_SALE();
  }

  S_SALE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_SALE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_SALE& from);
  void MergeFrom(const S_SALE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SALE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SALE";
  }
  protected:
  explicit S_SALE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kGoldFieldNumber = 1,
    kIdxFieldNumber = 2,
  };
  // .Protocol.PBItemData data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::Protocol::PBItemData& data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBItemData* release_data();
  ::Protocol::PBItemData* mutable_data();
  void set_allocated_data(::Protocol::PBItemData* data);
  private:
  const ::Protocol::PBItemData& _internal_data() const;
  ::Protocol::PBItemData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::Protocol::PBItemData* data);
  ::Protocol::PBItemData* unsafe_arena_release_data();

  // uint32 gold = 1;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::uint32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 idx = 2;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SALE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PBItemData* data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gold_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SWAP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SWAP_ITEM) */ {
 public:
  inline C_SWAP_ITEM() : C_SWAP_ITEM(nullptr) {}
  ~C_SWAP_ITEM() override;
  explicit constexpr C_SWAP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SWAP_ITEM(const C_SWAP_ITEM& from);
  C_SWAP_ITEM(C_SWAP_ITEM&& from) noexcept
    : C_SWAP_ITEM() {
    *this = ::std::move(from);
  }

  inline C_SWAP_ITEM& operator=(const C_SWAP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SWAP_ITEM& operator=(C_SWAP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SWAP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SWAP_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_SWAP_ITEM*>(
               &_C_SWAP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_SWAP_ITEM& a, C_SWAP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SWAP_ITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SWAP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_SWAP_ITEM* New() const final {
    return new C_SWAP_ITEM();
  }

  C_SWAP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_SWAP_ITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_SWAP_ITEM& from);
  void MergeFrom(const C_SWAP_ITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SWAP_ITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SWAP_ITEM";
  }
  protected:
  explicit C_SWAP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdx1FieldNumber = 1,
    kIdx2FieldNumber = 2,
  };
  // uint32 idx_1 = 1;
  void clear_idx_1();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1() const;
  void set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_1() const;
  void _internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 idx_2 = 2;
  void clear_idx_2();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2() const;
  void set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_2() const;
  void _internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SWAP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SWAP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SWAP_ITEM) */ {
 public:
  inline S_SWAP_ITEM() : S_SWAP_ITEM(nullptr) {}
  ~S_SWAP_ITEM() override;
  explicit constexpr S_SWAP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SWAP_ITEM(const S_SWAP_ITEM& from);
  S_SWAP_ITEM(S_SWAP_ITEM&& from) noexcept
    : S_SWAP_ITEM() {
    *this = ::std::move(from);
  }

  inline S_SWAP_ITEM& operator=(const S_SWAP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SWAP_ITEM& operator=(S_SWAP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SWAP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SWAP_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_SWAP_ITEM*>(
               &_S_SWAP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(S_SWAP_ITEM& a, S_SWAP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SWAP_ITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SWAP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_SWAP_ITEM* New() const final {
    return new S_SWAP_ITEM();
  }

  S_SWAP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_SWAP_ITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_SWAP_ITEM& from);
  void MergeFrom(const S_SWAP_ITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SWAP_ITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SWAP_ITEM";
  }
  protected:
  explicit S_SWAP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdx1FieldNumber = 1,
    kIdx2FieldNumber = 2,
  };
  // uint32 idx_1 = 1;
  void clear_idx_1();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1() const;
  void set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_1() const;
  void _internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 idx_2 = 2;
  void clear_idx_2();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2() const;
  void set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_2() const;
  void _internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SWAP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_USE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_USE_ITEM) */ {
 public:
  inline C_USE_ITEM() : C_USE_ITEM(nullptr) {}
  ~C_USE_ITEM() override;
  explicit constexpr C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USE_ITEM(const C_USE_ITEM& from);
  C_USE_ITEM(C_USE_ITEM&& from) noexcept
    : C_USE_ITEM() {
    *this = ::std::move(from);
  }

  inline C_USE_ITEM& operator=(const C_USE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USE_ITEM& operator=(C_USE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USE_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_USE_ITEM*>(
               &_C_USE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(C_USE_ITEM& a, C_USE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USE_ITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_USE_ITEM* New() const final {
    return new C_USE_ITEM();
  }

  C_USE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_USE_ITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_USE_ITEM& from);
  void MergeFrom(const C_USE_ITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USE_ITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_USE_ITEM";
  }
  protected:
  explicit C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // uint32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_USE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_USE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_USE_ITEM) */ {
 public:
  inline S_USE_ITEM() : S_USE_ITEM(nullptr) {}
  ~S_USE_ITEM() override;
  explicit constexpr S_USE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_USE_ITEM(const S_USE_ITEM& from);
  S_USE_ITEM(S_USE_ITEM&& from) noexcept
    : S_USE_ITEM() {
    *this = ::std::move(from);
  }

  inline S_USE_ITEM& operator=(const S_USE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_USE_ITEM& operator=(S_USE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_USE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_USE_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_USE_ITEM*>(
               &_S_USE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_USE_ITEM& a, S_USE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_USE_ITEM* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_USE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_USE_ITEM* New() const final {
    return new S_USE_ITEM();
  }

  S_USE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_USE_ITEM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_USE_ITEM& from);
  void MergeFrom(const S_USE_ITEM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_USE_ITEM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_USE_ITEM";
  }
  protected:
  explicit S_USE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipdataFieldNumber = 2,
    kInvendataFieldNumber = 4,
    kChardataFieldNumber = 5,
    kIdFieldNumber = 1,
    kInvenidxFieldNumber = 3,
  };
  // .Protocol.PBItemData equipdata = 2;
  bool has_equipdata() const;
  private:
  bool _internal_has_equipdata() const;
  public:
  void clear_equipdata();
  const ::Protocol::PBItemData& equipdata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBItemData* release_equipdata();
  ::Protocol::PBItemData* mutable_equipdata();
  void set_allocated_equipdata(::Protocol::PBItemData* equipdata);
  private:
  const ::Protocol::PBItemData& _internal_equipdata() const;
  ::Protocol::PBItemData* _internal_mutable_equipdata();
  public:
  void unsafe_arena_set_allocated_equipdata(
      ::Protocol::PBItemData* equipdata);
  ::Protocol::PBItemData* unsafe_arena_release_equipdata();

  // .Protocol.PBItemData invendata = 4;
  bool has_invendata() const;
  private:
  bool _internal_has_invendata() const;
  public:
  void clear_invendata();
  const ::Protocol::PBItemData& invendata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBItemData* release_invendata();
  ::Protocol::PBItemData* mutable_invendata();
  void set_allocated_invendata(::Protocol::PBItemData* invendata);
  private:
  const ::Protocol::PBItemData& _internal_invendata() const;
  ::Protocol::PBItemData* _internal_mutable_invendata();
  public:
  void unsafe_arena_set_allocated_invendata(
      ::Protocol::PBItemData* invendata);
  ::Protocol::PBItemData* unsafe_arena_release_invendata();

  // .Protocol.PBCharacterData chardata = 5;
  bool has_chardata() const;
  private:
  bool _internal_has_chardata() const;
  public:
  void clear_chardata();
  const ::Protocol::PBCharacterData& chardata() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PBCharacterData* release_chardata();
  ::Protocol::PBCharacterData* mutable_chardata();
  void set_allocated_chardata(::Protocol::PBCharacterData* chardata);
  private:
  const ::Protocol::PBCharacterData& _internal_chardata() const;
  ::Protocol::PBCharacterData* _internal_mutable_chardata();
  public:
  void unsafe_arena_set_allocated_chardata(
      ::Protocol::PBCharacterData* chardata);
  ::Protocol::PBCharacterData* unsafe_arena_release_chardata();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 invenidx = 3;
  void clear_invenidx();
  ::PROTOBUF_NAMESPACE_ID::uint32 invenidx() const;
  void set_invenidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_invenidx() const;
  void _internal_set_invenidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_USE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PBItemData* equipdata_;
  ::Protocol::PBItemData* invendata_;
  ::Protocol::PBCharacterData* chardata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 invenidx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_STAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_STAT) */ {
 public:
  inline S_STAT() : S_STAT(nullptr) {}
  ~S_STAT() override;
  explicit constexpr S_STAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_STAT(const S_STAT& from);
  S_STAT(S_STAT&& from) noexcept
    : S_STAT() {
    *this = ::std::move(from);
  }

  inline S_STAT& operator=(const S_STAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_STAT& operator=(S_STAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_STAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_STAT* internal_default_instance() {
    return reinterpret_cast<const S_STAT*>(
               &_S_STAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_STAT& a, S_STAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_STAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_STAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_STAT* New() const final {
    return new S_STAT();
  }

  S_STAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_STAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_STAT& from);
  void MergeFrom(const S_STAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_STAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_STAT";
  }
  protected:
  explicit S_STAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kMpFieldNumber = 3,
    kExpFieldNumber = 4,
    kMaxhpFieldNumber = 5,
    kMaxmpFieldNumber = 6,
    kDamageFieldNumber = 7,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float mp = 3;
  void clear_mp();
  float mp() const;
  void set_mp(float value);
  private:
  float _internal_mp() const;
  void _internal_set_mp(float value);
  public:

  // float exp = 4;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // float maxhp = 5;
  void clear_maxhp();
  float maxhp() const;
  void set_maxhp(float value);
  private:
  float _internal_maxhp() const;
  void _internal_set_maxhp(float value);
  public:

  // float maxmp = 6;
  void clear_maxmp();
  float maxmp() const;
  void set_maxmp(float value);
  private:
  float _internal_maxmp() const;
  void _internal_set_maxmp(float value);
  public:

  // float damage = 7;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_STAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float hp_;
  float mp_;
  float exp_;
  float maxhp_;
  float maxmp_;
  float damage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_STAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_STAT) */ {
 public:
  inline C_STAT() : C_STAT(nullptr) {}
  ~C_STAT() override;
  explicit constexpr C_STAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_STAT(const C_STAT& from);
  C_STAT(C_STAT&& from) noexcept
    : C_STAT() {
    *this = ::std::move(from);
  }

  inline C_STAT& operator=(const C_STAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_STAT& operator=(C_STAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_STAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_STAT* internal_default_instance() {
    return reinterpret_cast<const C_STAT*>(
               &_C_STAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_STAT& a, C_STAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_STAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_STAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_STAT* New() const final {
    return new C_STAT();
  }

  C_STAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_STAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_STAT& from);
  void MergeFrom(const C_STAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_STAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_STAT";
  }
  protected:
  explicit C_STAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kMpFieldNumber = 3,
    kExpFieldNumber = 4,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float mp = 3;
  void clear_mp();
  float mp() const;
  void set_mp(float value);
  private:
  float _internal_mp() const;
  void _internal_set_mp(float value);
  public:

  // float exp = 4;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_STAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float hp_;
  float mp_;
  float exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DEAD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DEAD) */ {
 public:
  inline S_DEAD() : S_DEAD(nullptr) {}
  ~S_DEAD() override;
  explicit constexpr S_DEAD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DEAD(const S_DEAD& from);
  S_DEAD(S_DEAD&& from) noexcept
    : S_DEAD() {
    *this = ::std::move(from);
  }

  inline S_DEAD& operator=(const S_DEAD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DEAD& operator=(S_DEAD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DEAD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DEAD* internal_default_instance() {
    return reinterpret_cast<const S_DEAD*>(
               &_S_DEAD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_DEAD& a, S_DEAD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DEAD* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DEAD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_DEAD* New() const final {
    return new S_DEAD();
  }

  S_DEAD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_DEAD>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_DEAD& from);
  void MergeFrom(const S_DEAD& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DEAD* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DEAD";
  }
  protected:
  explicit S_DEAD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_DEAD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_RESPAWN) */ {
 public:
  inline C_RESPAWN() : C_RESPAWN(nullptr) {}
  ~C_RESPAWN() override;
  explicit constexpr C_RESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RESPAWN(const C_RESPAWN& from);
  C_RESPAWN(C_RESPAWN&& from) noexcept
    : C_RESPAWN() {
    *this = ::std::move(from);
  }

  inline C_RESPAWN& operator=(const C_RESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RESPAWN& operator=(C_RESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RESPAWN* internal_default_instance() {
    return reinterpret_cast<const C_RESPAWN*>(
               &_C_RESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(C_RESPAWN& a, C_RESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RESPAWN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_RESPAWN* New() const final {
    return new C_RESPAWN();
  }

  C_RESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_RESPAWN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_RESPAWN& from);
  void MergeFrom(const C_RESPAWN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RESPAWN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RESPAWN";
  }
  protected:
  explicit C_RESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_RESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RESPAWN) */ {
 public:
  inline S_RESPAWN() : S_RESPAWN(nullptr) {}
  ~S_RESPAWN() override;
  explicit constexpr S_RESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RESPAWN(const S_RESPAWN& from);
  S_RESPAWN(S_RESPAWN&& from) noexcept
    : S_RESPAWN() {
    *this = ::std::move(from);
  }

  inline S_RESPAWN& operator=(const S_RESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RESPAWN& operator=(S_RESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_RESPAWN*>(
               &_S_RESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_RESPAWN& a, S_RESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RESPAWN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_RESPAWN* New() const final {
    return new S_RESPAWN();
  }

  S_RESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_RESPAWN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_RESPAWN& from);
  void MergeFrom(const S_RESPAWN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RESPAWN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RESPAWN";
  }
  protected:
  explicit S_RESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdx1FieldNumber = 1,
    kIdx2FieldNumber = 2,
  };
  // uint32 idx_1 = 1;
  void clear_idx_1();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1() const;
  void set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_1() const;
  void _internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 idx_2 = 2;
  void clear_idx_2();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2() const;
  void set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx_2() const;
  void _internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_RESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UNEQUIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UNEQUIP) */ {
 public:
  inline C_UNEQUIP() : C_UNEQUIP(nullptr) {}
  ~C_UNEQUIP() override;
  explicit constexpr C_UNEQUIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UNEQUIP(const C_UNEQUIP& from);
  C_UNEQUIP(C_UNEQUIP&& from) noexcept
    : C_UNEQUIP() {
    *this = ::std::move(from);
  }

  inline C_UNEQUIP& operator=(const C_UNEQUIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UNEQUIP& operator=(C_UNEQUIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UNEQUIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UNEQUIP* internal_default_instance() {
    return reinterpret_cast<const C_UNEQUIP*>(
               &_C_UNEQUIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_UNEQUIP& a, C_UNEQUIP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UNEQUIP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UNEQUIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_UNEQUIP* New() const final {
    return new C_UNEQUIP();
  }

  C_UNEQUIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_UNEQUIP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_UNEQUIP& from);
  void MergeFrom(const C_UNEQUIP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UNEQUIP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UNEQUIP";
  }
  protected:
  explicit C_UNEQUIP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // uint32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UNEQUIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UNEQUIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UNEQUIP) */ {
 public:
  inline S_UNEQUIP() : S_UNEQUIP(nullptr) {}
  ~S_UNEQUIP() override;
  explicit constexpr S_UNEQUIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UNEQUIP(const S_UNEQUIP& from);
  S_UNEQUIP(S_UNEQUIP&& from) noexcept
    : S_UNEQUIP() {
    *this = ::std::move(from);
  }

  inline S_UNEQUIP& operator=(const S_UNEQUIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UNEQUIP& operator=(S_UNEQUIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UNEQUIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UNEQUIP* internal_default_instance() {
    return reinterpret_cast<const S_UNEQUIP*>(
               &_S_UNEQUIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_UNEQUIP& a, S_UNEQUIP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UNEQUIP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UNEQUIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_UNEQUIP* New() const final {
    return new S_UNEQUIP();
  }

  S_UNEQUIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_UNEQUIP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_UNEQUIP& from);
  void MergeFrom(const S_UNEQUIP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UNEQUIP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UNEQUIP";
  }
  protected:
  explicit S_UNEQUIP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIdxFieldNumber = 2,
  };
  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 idx = 2;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UNEQUIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EXP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EXP) */ {
 public:
  inline S_EXP() : S_EXP(nullptr) {}
  ~S_EXP() override;
  explicit constexpr S_EXP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EXP(const S_EXP& from);
  S_EXP(S_EXP&& from) noexcept
    : S_EXP() {
    *this = ::std::move(from);
  }

  inline S_EXP& operator=(const S_EXP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EXP& operator=(S_EXP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EXP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EXP* internal_default_instance() {
    return reinterpret_cast<const S_EXP*>(
               &_S_EXP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(S_EXP& a, S_EXP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EXP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EXP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_EXP* New() const final {
    return new S_EXP();
  }

  S_EXP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_EXP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_EXP& from);
  void MergeFrom(const S_EXP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EXP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EXP";
  }
  protected:
  explicit S_EXP(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kExpFieldNumber = 2,
    kMaxexpFieldNumber = 3,
  };
  // uint32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::uint32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float exp = 2;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // float maxexp = 3;
  void clear_maxexp();
  float maxexp() const;
  void set_maxexp(float value);
  private:
  float _internal_maxexp() const;
  void _internal_set_maxexp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EXP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 level_;
  float exp_;
  float maxexp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_SERVERCONNECT

// bool success = 1;
inline void S_SERVERCONNECT::clear_success() {
  success_ = false;
}
inline bool S_SERVERCONNECT::_internal_success() const {
  return success_;
}
inline bool S_SERVERCONNECT::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SERVERCONNECT.success)
  return _internal_success();
}
inline void S_SERVERCONNECT::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_SERVERCONNECT::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SERVERCONNECT.success)
}

// -------------------------------------------------------------------

// C_SIGNUP

// string id = 1;
inline void C_SIGNUP::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_SIGNUP::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SIGNUP.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SIGNUP::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SIGNUP.id)
}
inline std::string* C_SIGNUP::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_SIGNUP.id)
  return _internal_mutable_id();
}
inline const std::string& C_SIGNUP::_internal_id() const {
  return id_.Get();
}
inline void C_SIGNUP::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_SIGNUP::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_SIGNUP::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_SIGNUP.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_SIGNUP::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SIGNUP.id)
}

// string password = 2;
inline void C_SIGNUP::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& C_SIGNUP::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SIGNUP.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SIGNUP::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SIGNUP.password)
}
inline std::string* C_SIGNUP::mutable_password() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_SIGNUP.password)
  return _internal_mutable_password();
}
inline const std::string& C_SIGNUP::_internal_password() const {
  return password_.Get();
}
inline void C_SIGNUP::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_SIGNUP::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_SIGNUP::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_SIGNUP.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_SIGNUP::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SIGNUP.password)
}

// -------------------------------------------------------------------

// S_SIGNUP

// bool success = 1;
inline void S_SIGNUP::clear_success() {
  success_ = false;
}
inline bool S_SIGNUP::_internal_success() const {
  return success_;
}
inline bool S_SIGNUP::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SIGNUP.success)
  return _internal_success();
}
inline void S_SIGNUP::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_SIGNUP::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SIGNUP.success)
}

// -------------------------------------------------------------------

// C_LOGIN

// string id = 1;
inline void C_LOGIN::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.id)
}
inline std::string* C_LOGIN::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.id)
  return _internal_mutable_id();
}
inline const std::string& C_LOGIN::_internal_id() const {
  return id_.Get();
}
inline void C_LOGIN::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.id)
}

// string password = 2;
inline void C_LOGIN::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& C_LOGIN::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.password)
}
inline std::string* C_LOGIN::mutable_password() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.password)
  return _internal_mutable_password();
}
inline const std::string& C_LOGIN::_internal_password() const {
  return password_.Get();
}
inline void C_LOGIN::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_LOGIN::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.password)
}

// -------------------------------------------------------------------

// S_LOGIN

// bool success = 1;
inline void S_LOGIN::clear_success() {
  success_ = false;
}
inline bool S_LOGIN::_internal_success() const {
  return success_;
}
inline bool S_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.success)
  return _internal_success();
}
inline void S_LOGIN::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.success)
}

// -------------------------------------------------------------------

// C_CREATECHARACTER

// .Protocol.PlayerType type = 1;
inline void C_CREATECHARACTER::clear_type() {
  type_ = 0;
}
inline ::Protocol::PlayerType C_CREATECHARACTER::_internal_type() const {
  return static_cast< ::Protocol::PlayerType >(type_);
}
inline ::Protocol::PlayerType C_CREATECHARACTER::type() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.type)
  return _internal_type();
}
inline void C_CREATECHARACTER::_internal_set_type(::Protocol::PlayerType value) {
  
  type_ = value;
}
inline void C_CREATECHARACTER::set_type(::Protocol::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.type)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// -------------------------------------------------------------------

// S_ENTER_GAME

// uint64 mapid = 1;
inline void S_ENTER_GAME::clear_mapid() {
  mapid_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_ENTER_GAME::_internal_mapid() const {
  return mapid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_ENTER_GAME::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.mapid)
  return _internal_mapid();
}
inline void S_ENTER_GAME::_internal_set_mapid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  mapid_ = value;
}
inline void S_ENTER_GAME::set_mapid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.mapid)
}

// uint64 id = 2;
inline void S_ENTER_GAME::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_ENTER_GAME::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_ENTER_GAME::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.id)
  return _internal_id();
}
inline void S_ENTER_GAME::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void S_ENTER_GAME::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.id)
}

// .Protocol.PBCharacterData characterInfo = 3;
inline bool S_ENTER_GAME::_internal_has_characterinfo() const {
  return this != internal_default_instance() && characterinfo_ != nullptr;
}
inline bool S_ENTER_GAME::has_characterinfo() const {
  return _internal_has_characterinfo();
}
inline const ::Protocol::PBCharacterData& S_ENTER_GAME::_internal_characterinfo() const {
  const ::Protocol::PBCharacterData* p = characterinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBCharacterData&>(
      ::Protocol::_PBCharacterData_default_instance_);
}
inline const ::Protocol::PBCharacterData& S_ENTER_GAME::characterinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.characterInfo)
  return _internal_characterinfo();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_characterinfo(
    ::Protocol::PBCharacterData* characterinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo_);
  }
  characterinfo_ = characterinfo;
  if (characterinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.characterInfo)
}
inline ::Protocol::PBCharacterData* S_ENTER_GAME::release_characterinfo() {
  
  ::Protocol::PBCharacterData* temp = characterinfo_;
  characterinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBCharacterData* S_ENTER_GAME::unsafe_arena_release_characterinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.characterInfo)
  
  ::Protocol::PBCharacterData* temp = characterinfo_;
  characterinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PBCharacterData* S_ENTER_GAME::_internal_mutable_characterinfo() {
  
  if (characterinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBCharacterData>(GetArenaForAllocation());
    characterinfo_ = p;
  }
  return characterinfo_;
}
inline ::Protocol::PBCharacterData* S_ENTER_GAME::mutable_characterinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.characterInfo)
  return _internal_mutable_characterinfo();
}
inline void S_ENTER_GAME::set_allocated_characterinfo(::Protocol::PBCharacterData* characterinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo_);
  }
  if (characterinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo));
    if (message_arena != submessage_arena) {
      characterinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterinfo, submessage_arena);
    }
    
  } else {
    
  }
  characterinfo_ = characterinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.characterInfo)
}

// repeated .Protocol.PBItemData inven = 4;
inline int S_ENTER_GAME::_internal_inven_size() const {
  return inven_.size();
}
inline int S_ENTER_GAME::inven_size() const {
  return _internal_inven_size();
}
inline ::Protocol::PBItemData* S_ENTER_GAME::mutable_inven(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.inven)
  return inven_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
S_ENTER_GAME::mutable_inven() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ENTER_GAME.inven)
  return &inven_;
}
inline const ::Protocol::PBItemData& S_ENTER_GAME::_internal_inven(int index) const {
  return inven_.Get(index);
}
inline const ::Protocol::PBItemData& S_ENTER_GAME::inven(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.inven)
  return _internal_inven(index);
}
inline ::Protocol::PBItemData* S_ENTER_GAME::_internal_add_inven() {
  return inven_.Add();
}
inline ::Protocol::PBItemData* S_ENTER_GAME::add_inven() {
  // @@protoc_insertion_point(field_add:Protocol.S_ENTER_GAME.inven)
  return _internal_add_inven();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
S_ENTER_GAME::inven() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ENTER_GAME.inven)
  return inven_;
}

// repeated .Protocol.PBItemData equip = 5;
inline int S_ENTER_GAME::_internal_equip_size() const {
  return equip_.size();
}
inline int S_ENTER_GAME::equip_size() const {
  return _internal_equip_size();
}
inline ::Protocol::PBItemData* S_ENTER_GAME::mutable_equip(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.equip)
  return equip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
S_ENTER_GAME::mutable_equip() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ENTER_GAME.equip)
  return &equip_;
}
inline const ::Protocol::PBItemData& S_ENTER_GAME::_internal_equip(int index) const {
  return equip_.Get(index);
}
inline const ::Protocol::PBItemData& S_ENTER_GAME::equip(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.equip)
  return _internal_equip(index);
}
inline ::Protocol::PBItemData* S_ENTER_GAME::_internal_add_equip() {
  return equip_.Add();
}
inline ::Protocol::PBItemData* S_ENTER_GAME::add_equip() {
  // @@protoc_insertion_point(field_add:Protocol.S_ENTER_GAME.equip)
  return _internal_add_equip();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
S_ENTER_GAME::equip() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ENTER_GAME.equip)
  return equip_;
}

// -------------------------------------------------------------------

// S_SPAWN

// bool ismy = 1;
inline void S_SPAWN::clear_ismy() {
  ismy_ = false;
}
inline bool S_SPAWN::_internal_ismy() const {
  return ismy_;
}
inline bool S_SPAWN::ismy() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.ismy)
  return _internal_ismy();
}
inline void S_SPAWN::_internal_set_ismy(bool value) {
  
  ismy_ = value;
}
inline void S_SPAWN::set_ismy(bool value) {
  _internal_set_ismy(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SPAWN.ismy)
}

// repeated .Protocol.ObjectInfo objectInfos = 2;
inline int S_SPAWN::_internal_objectinfos_size() const {
  return objectinfos_.size();
}
inline int S_SPAWN::objectinfos_size() const {
  return _internal_objectinfos_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_objectinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.objectInfos)
  return objectinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_objectinfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.objectInfos)
  return &objectinfos_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_objectinfos(int index) const {
  return objectinfos_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::objectinfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.objectInfos)
  return _internal_objectinfos(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_objectinfos() {
  return objectinfos_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_objectinfos() {
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.objectInfos)
  return _internal_add_objectinfos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::objectinfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.objectInfos)
  return objectinfos_;
}

// .Protocol.PBCharacterData characterInfo = 3;
inline bool S_SPAWN::_internal_has_characterinfo() const {
  return this != internal_default_instance() && characterinfo_ != nullptr;
}
inline bool S_SPAWN::has_characterinfo() const {
  return _internal_has_characterinfo();
}
inline const ::Protocol::PBCharacterData& S_SPAWN::_internal_characterinfo() const {
  const ::Protocol::PBCharacterData* p = characterinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBCharacterData&>(
      ::Protocol::_PBCharacterData_default_instance_);
}
inline const ::Protocol::PBCharacterData& S_SPAWN::characterinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.characterInfo)
  return _internal_characterinfo();
}
inline void S_SPAWN::unsafe_arena_set_allocated_characterinfo(
    ::Protocol::PBCharacterData* characterinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo_);
  }
  characterinfo_ = characterinfo;
  if (characterinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SPAWN.characterInfo)
}
inline ::Protocol::PBCharacterData* S_SPAWN::release_characterinfo() {
  
  ::Protocol::PBCharacterData* temp = characterinfo_;
  characterinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBCharacterData* S_SPAWN::unsafe_arena_release_characterinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_SPAWN.characterInfo)
  
  ::Protocol::PBCharacterData* temp = characterinfo_;
  characterinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PBCharacterData* S_SPAWN::_internal_mutable_characterinfo() {
  
  if (characterinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBCharacterData>(GetArenaForAllocation());
    characterinfo_ = p;
  }
  return characterinfo_;
}
inline ::Protocol::PBCharacterData* S_SPAWN::mutable_characterinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.characterInfo)
  return _internal_mutable_characterinfo();
}
inline void S_SPAWN::set_allocated_characterinfo(::Protocol::PBCharacterData* characterinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo_);
  }
  if (characterinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(characterinfo));
    if (message_arena != submessage_arena) {
      characterinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, characterinfo, submessage_arena);
    }
    
  } else {
    
  }
  characterinfo_ = characterinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SPAWN.characterInfo)
}

// repeated .Protocol.PBItemData inven = 4;
inline int S_SPAWN::_internal_inven_size() const {
  return inven_.size();
}
inline int S_SPAWN::inven_size() const {
  return _internal_inven_size();
}
inline ::Protocol::PBItemData* S_SPAWN::mutable_inven(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.inven)
  return inven_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
S_SPAWN::mutable_inven() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.inven)
  return &inven_;
}
inline const ::Protocol::PBItemData& S_SPAWN::_internal_inven(int index) const {
  return inven_.Get(index);
}
inline const ::Protocol::PBItemData& S_SPAWN::inven(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.inven)
  return _internal_inven(index);
}
inline ::Protocol::PBItemData* S_SPAWN::_internal_add_inven() {
  return inven_.Add();
}
inline ::Protocol::PBItemData* S_SPAWN::add_inven() {
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.inven)
  return _internal_add_inven();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
S_SPAWN::inven() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.inven)
  return inven_;
}

// repeated .Protocol.PBItemData equip = 5;
inline int S_SPAWN::_internal_equip_size() const {
  return equip_.size();
}
inline int S_SPAWN::equip_size() const {
  return _internal_equip_size();
}
inline ::Protocol::PBItemData* S_SPAWN::mutable_equip(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.equip)
  return equip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >*
S_SPAWN::mutable_equip() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.equip)
  return &equip_;
}
inline const ::Protocol::PBItemData& S_SPAWN::_internal_equip(int index) const {
  return equip_.Get(index);
}
inline const ::Protocol::PBItemData& S_SPAWN::equip(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.equip)
  return _internal_equip(index);
}
inline ::Protocol::PBItemData* S_SPAWN::_internal_add_equip() {
  return equip_.Add();
}
inline ::Protocol::PBItemData* S_SPAWN::add_equip() {
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.equip)
  return _internal_add_equip();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PBItemData >&
S_SPAWN::equip() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.equip)
  return equip_;
}

// -------------------------------------------------------------------

// S_LEAVE

// .Protocol.ObjectInfo objectInfo = 1;
inline bool S_LEAVE::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_LEAVE::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_LEAVE::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_LEAVE::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEAVE.objectInfo)
  return _internal_objectinfo();
}
inline void S_LEAVE::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_LEAVE.objectInfo)
}
inline ::Protocol::ObjectInfo* S_LEAVE::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_LEAVE::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_LEAVE.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_LEAVE::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_LEAVE::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LEAVE.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void S_LEAVE::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_LEAVE.objectInfo)
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.ObjectInfo objectInfo = 1;
inline bool C_MOVE::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_MOVE::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_MOVE::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_MOVE::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.objectInfo)
  return _internal_objectinfo();
}
inline void C_MOVE::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.objectInfo)
}
inline ::Protocol::ObjectInfo* C_MOVE::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* C_MOVE::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_MOVE::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_MOVE::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void C_MOVE::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.objectInfo)
}

// -------------------------------------------------------------------

// S_MOVE

// .Protocol.ObjectInfo objectInfo = 1;
inline bool S_MOVE::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_MOVE::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_MOVE::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_MOVE::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.objectInfo)
  return _internal_objectinfo();
}
inline void S_MOVE::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.objectInfo)
}
inline ::Protocol::ObjectInfo* S_MOVE::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_MOVE::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_MOVE::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_MOVE::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void S_MOVE::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.objectInfo)
}

// .Protocol.StateType state = 2;
inline void S_MOVE::clear_state() {
  state_ = 0;
}
inline ::Protocol::StateType S_MOVE::_internal_state() const {
  return static_cast< ::Protocol::StateType >(state_);
}
inline ::Protocol::StateType S_MOVE::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.state)
  return _internal_state();
}
inline void S_MOVE::_internal_set_state(::Protocol::StateType value) {
  
  state_ = value;
}
inline void S_MOVE::set_state(::Protocol::StateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVE.state)
}

// .Protocol.PBVector MoveLocation = 3;
inline bool S_MOVE::_internal_has_movelocation() const {
  return this != internal_default_instance() && movelocation_ != nullptr;
}
inline bool S_MOVE::has_movelocation() const {
  return _internal_has_movelocation();
}
inline const ::Protocol::PBVector& S_MOVE::_internal_movelocation() const {
  const ::Protocol::PBVector* p = movelocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBVector&>(
      ::Protocol::_PBVector_default_instance_);
}
inline const ::Protocol::PBVector& S_MOVE::movelocation() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.MoveLocation)
  return _internal_movelocation();
}
inline void S_MOVE::unsafe_arena_set_allocated_movelocation(
    ::Protocol::PBVector* movelocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movelocation_);
  }
  movelocation_ = movelocation;
  if (movelocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.MoveLocation)
}
inline ::Protocol::PBVector* S_MOVE::release_movelocation() {
  
  ::Protocol::PBVector* temp = movelocation_;
  movelocation_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBVector* S_MOVE::unsafe_arena_release_movelocation() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.MoveLocation)
  
  ::Protocol::PBVector* temp = movelocation_;
  movelocation_ = nullptr;
  return temp;
}
inline ::Protocol::PBVector* S_MOVE::_internal_mutable_movelocation() {
  
  if (movelocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBVector>(GetArenaForAllocation());
    movelocation_ = p;
  }
  return movelocation_;
}
inline ::Protocol::PBVector* S_MOVE::mutable_movelocation() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.MoveLocation)
  return _internal_mutable_movelocation();
}
inline void S_MOVE::set_allocated_movelocation(::Protocol::PBVector* movelocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(movelocation_);
  }
  if (movelocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movelocation));
    if (message_arena != submessage_arena) {
      movelocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, movelocation, submessage_arena);
    }
    
  } else {
    
  }
  movelocation_ = movelocation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.MoveLocation)
}

// -------------------------------------------------------------------

// C_ATTACK

// .Protocol.ObjectInfo objectInfo = 1;
inline bool C_ATTACK::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_ATTACK::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_ATTACK::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_ATTACK::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.objectInfo)
  return _internal_objectinfo();
}
inline void C_ATTACK::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_ATTACK.objectInfo)
}
inline ::Protocol::ObjectInfo* C_ATTACK::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* C_ATTACK::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_ATTACK.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_ATTACK::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_ATTACK::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_ATTACK.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void C_ATTACK::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ATTACK.objectInfo)
}

// uint32 attackId = 2;
inline void C_ATTACK::clear_attackid() {
  attackid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_ATTACK::_internal_attackid() const {
  return attackid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_ATTACK::attackid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.attackId)
  return _internal_attackid();
}
inline void C_ATTACK::_internal_set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  attackid_ = value;
}
inline void C_ATTACK::set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_attackid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.attackId)
}

// -------------------------------------------------------------------

// S_ATTACK

// .Protocol.ObjectInfo objectInfo = 1;
inline bool S_ATTACK::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_ATTACK::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_ATTACK::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ATTACK::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.objectInfo)
  return _internal_objectinfo();
}
inline void S_ATTACK::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ATTACK.objectInfo)
}
inline ::Protocol::ObjectInfo* S_ATTACK::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_ATTACK::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ATTACK.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ATTACK::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_ATTACK::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ATTACK.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void S_ATTACK::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ATTACK.objectInfo)
}

// uint32 attackId = 2;
inline void S_ATTACK::clear_attackid() {
  attackid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_ATTACK::_internal_attackid() const {
  return attackid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_ATTACK::attackid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.attackId)
  return _internal_attackid();
}
inline void S_ATTACK::_internal_set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  attackid_ = value;
}
inline void S_ATTACK::set_attackid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_attackid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.attackId)
}

// .Protocol.StateType state = 3;
inline void S_ATTACK::clear_state() {
  state_ = 0;
}
inline ::Protocol::StateType S_ATTACK::_internal_state() const {
  return static_cast< ::Protocol::StateType >(state_);
}
inline ::Protocol::StateType S_ATTACK::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.state)
  return _internal_state();
}
inline void S_ATTACK::_internal_set_state(::Protocol::StateType value) {
  
  state_ = value;
}
inline void S_ATTACK::set_state(::Protocol::StateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.state)
}

// -------------------------------------------------------------------

// S_STATE

// .Protocol.ObjectInfo objectInfo = 1;
inline bool S_STATE::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_STATE::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_STATE::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_STATE::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATE.objectInfo)
  return _internal_objectinfo();
}
inline void S_STATE::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_STATE.objectInfo)
}
inline ::Protocol::ObjectInfo* S_STATE::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_STATE::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_STATE.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_STATE::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_STATE::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_STATE.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void S_STATE::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_STATE.objectInfo)
}

// .Protocol.StateType state = 2;
inline void S_STATE::clear_state() {
  state_ = 0;
}
inline ::Protocol::StateType S_STATE::_internal_state() const {
  return static_cast< ::Protocol::StateType >(state_);
}
inline ::Protocol::StateType S_STATE::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATE.state)
  return _internal_state();
}
inline void S_STATE::_internal_set_state(::Protocol::StateType value) {
  
  state_ = value;
}
inline void S_STATE::set_state(::Protocol::StateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STATE.state)
}

// uint32 skillid = 3;
inline void S_STATE::clear_skillid() {
  skillid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_STATE::_internal_skillid() const {
  return skillid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_STATE::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATE.skillid)
  return _internal_skillid();
}
inline void S_STATE::_internal_set_skillid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  skillid_ = value;
}
inline void S_STATE::set_skillid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STATE.skillid)
}

// -------------------------------------------------------------------

// C_CHAT

// string msg = 1;
inline void C_CHAT::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& C_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.msg)
}
inline std::string* C_CHAT::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.msg)
  return _internal_mutable_msg();
}
inline const std::string& C_CHAT::_internal_msg() const {
  return msg_.Get();
}
inline void C_CHAT::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.msg)
}

// -------------------------------------------------------------------

// S_CHAT

// uint64 playerId = 1;
inline void S_CHAT::clear_playerid() {
  playerid_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_CHAT::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_CHAT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.playerId)
  return _internal_playerid();
}
inline void S_CHAT::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  playerid_ = value;
}
inline void S_CHAT::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.playerId)
}

// string msg = 2;
inline void S_CHAT::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& S_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.msg)
}
inline std::string* S_CHAT::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.msg)
  return _internal_mutable_msg();
}
inline const std::string& S_CHAT::_internal_msg() const {
  return msg_.Get();
}
inline void S_CHAT::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.msg)
}

// -------------------------------------------------------------------

// C_GETITEM

// uint32 id = 1;
inline void C_GETITEM::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_GETITEM::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_GETITEM::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_GETITEM.id)
  return _internal_id();
}
inline void C_GETITEM::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void C_GETITEM::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_GETITEM.id)
}

// -------------------------------------------------------------------

// S_GETITEM

// .Protocol.PBItemData data = 1;
inline bool S_GETITEM::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool S_GETITEM::has_data() const {
  return _internal_has_data();
}
inline const ::Protocol::PBItemData& S_GETITEM::_internal_data() const {
  const ::Protocol::PBItemData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBItemData&>(
      ::Protocol::_PBItemData_default_instance_);
}
inline const ::Protocol::PBItemData& S_GETITEM::data() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GETITEM.data)
  return _internal_data();
}
inline void S_GETITEM::unsafe_arena_set_allocated_data(
    ::Protocol::PBItemData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_GETITEM.data)
}
inline ::Protocol::PBItemData* S_GETITEM::release_data() {
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBItemData* S_GETITEM::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:Protocol.S_GETITEM.data)
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::Protocol::PBItemData* S_GETITEM::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBItemData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::Protocol::PBItemData* S_GETITEM::mutable_data() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_GETITEM.data)
  return _internal_mutable_data();
}
inline void S_GETITEM::set_allocated_data(::Protocol::PBItemData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_GETITEM.data)
}

// uint32 idx = 2;
inline void S_GETITEM::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_GETITEM::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_GETITEM::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GETITEM.idx)
  return _internal_idx();
}
inline void S_GETITEM::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void S_GETITEM::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GETITEM.idx)
}

// -------------------------------------------------------------------

// C_CLICKNPC

// uint32 id = 1;
inline void C_CLICKNPC::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_CLICKNPC::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_CLICKNPC::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CLICKNPC.id)
  return _internal_id();
}
inline void C_CLICKNPC::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void C_CLICKNPC::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CLICKNPC.id)
}

// -------------------------------------------------------------------

// S_CLICKNPC

// repeated uint32 ids = 1;
inline int S_CLICKNPC::_internal_ids_size() const {
  return ids_.size();
}
inline int S_CLICKNPC::ids_size() const {
  return _internal_ids_size();
}
inline void S_CLICKNPC::clear_ids() {
  ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_CLICKNPC::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_CLICKNPC::ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_CLICKNPC.ids)
  return _internal_ids(index);
}
inline void S_CLICKNPC::set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_CLICKNPC.ids)
}
inline void S_CLICKNPC::_internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  ids_.Add(value);
}
inline void S_CLICKNPC::add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_CLICKNPC.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
S_CLICKNPC::_internal_ids() const {
  return ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
S_CLICKNPC::ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_CLICKNPC.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
S_CLICKNPC::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
S_CLICKNPC::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_CLICKNPC.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// C_PURCHASE

// uint32 id = 1;
inline void C_PURCHASE::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_PURCHASE::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_PURCHASE::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PURCHASE.id)
  return _internal_id();
}
inline void C_PURCHASE::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void C_PURCHASE::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PURCHASE.id)
}

// uint32 cnt = 2;
inline void C_PURCHASE::clear_cnt() {
  cnt_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_PURCHASE::_internal_cnt() const {
  return cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_PURCHASE::cnt() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PURCHASE.cnt)
  return _internal_cnt();
}
inline void C_PURCHASE::_internal_set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  cnt_ = value;
}
inline void C_PURCHASE::set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PURCHASE.cnt)
}

// -------------------------------------------------------------------

// S_PURCHASE

// .Protocol.PBItemData data = 1;
inline bool S_PURCHASE::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool S_PURCHASE::has_data() const {
  return _internal_has_data();
}
inline const ::Protocol::PBItemData& S_PURCHASE::_internal_data() const {
  const ::Protocol::PBItemData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBItemData&>(
      ::Protocol::_PBItemData_default_instance_);
}
inline const ::Protocol::PBItemData& S_PURCHASE::data() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PURCHASE.data)
  return _internal_data();
}
inline void S_PURCHASE::unsafe_arena_set_allocated_data(
    ::Protocol::PBItemData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_PURCHASE.data)
}
inline ::Protocol::PBItemData* S_PURCHASE::release_data() {
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBItemData* S_PURCHASE::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:Protocol.S_PURCHASE.data)
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::Protocol::PBItemData* S_PURCHASE::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBItemData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::Protocol::PBItemData* S_PURCHASE::mutable_data() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_PURCHASE.data)
  return _internal_mutable_data();
}
inline void S_PURCHASE::set_allocated_data(::Protocol::PBItemData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_PURCHASE.data)
}

// uint32 idx = 2;
inline void S_PURCHASE::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_PURCHASE::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_PURCHASE::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PURCHASE.idx)
  return _internal_idx();
}
inline void S_PURCHASE::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void S_PURCHASE::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PURCHASE.idx)
}

// uint32 gold = 3;
inline void S_PURCHASE::clear_gold() {
  gold_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_PURCHASE::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_PURCHASE::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PURCHASE.gold)
  return _internal_gold();
}
inline void S_PURCHASE::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  gold_ = value;
}
inline void S_PURCHASE::set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PURCHASE.gold)
}

// -------------------------------------------------------------------

// C_SALE

// uint32 idx = 1;
inline void C_SALE::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SALE::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SALE::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SALE.idx)
  return _internal_idx();
}
inline void C_SALE::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void C_SALE::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SALE.idx)
}

// uint32 cnt = 2;
inline void C_SALE::clear_cnt() {
  cnt_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SALE::_internal_cnt() const {
  return cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SALE::cnt() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SALE.cnt)
  return _internal_cnt();
}
inline void C_SALE::_internal_set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  cnt_ = value;
}
inline void C_SALE::set_cnt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SALE.cnt)
}

// -------------------------------------------------------------------

// S_SALE

// uint32 gold = 1;
inline void S_SALE::clear_gold() {
  gold_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SALE::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SALE::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SALE.gold)
  return _internal_gold();
}
inline void S_SALE::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  gold_ = value;
}
inline void S_SALE::set_gold(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SALE.gold)
}

// uint32 idx = 2;
inline void S_SALE::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SALE::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SALE::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SALE.idx)
  return _internal_idx();
}
inline void S_SALE::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void S_SALE::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SALE.idx)
}

// .Protocol.PBItemData data = 3;
inline bool S_SALE::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool S_SALE::has_data() const {
  return _internal_has_data();
}
inline const ::Protocol::PBItemData& S_SALE::_internal_data() const {
  const ::Protocol::PBItemData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBItemData&>(
      ::Protocol::_PBItemData_default_instance_);
}
inline const ::Protocol::PBItemData& S_SALE::data() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SALE.data)
  return _internal_data();
}
inline void S_SALE::unsafe_arena_set_allocated_data(
    ::Protocol::PBItemData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SALE.data)
}
inline ::Protocol::PBItemData* S_SALE::release_data() {
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBItemData* S_SALE::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:Protocol.S_SALE.data)
  
  ::Protocol::PBItemData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::Protocol::PBItemData* S_SALE::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBItemData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::Protocol::PBItemData* S_SALE::mutable_data() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SALE.data)
  return _internal_mutable_data();
}
inline void S_SALE::set_allocated_data(::Protocol::PBItemData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SALE.data)
}

// -------------------------------------------------------------------

// C_SWAP_ITEM

// uint32 idx_1 = 1;
inline void C_SWAP_ITEM::clear_idx_1() {
  idx_1_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SWAP_ITEM::_internal_idx_1() const {
  return idx_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SWAP_ITEM::idx_1() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_ITEM.idx_1)
  return _internal_idx_1();
}
inline void C_SWAP_ITEM::_internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_1_ = value;
}
inline void C_SWAP_ITEM::set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_1(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_ITEM.idx_1)
}

// uint32 idx_2 = 2;
inline void C_SWAP_ITEM::clear_idx_2() {
  idx_2_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SWAP_ITEM::_internal_idx_2() const {
  return idx_2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_SWAP_ITEM::idx_2() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SWAP_ITEM.idx_2)
  return _internal_idx_2();
}
inline void C_SWAP_ITEM::_internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_2_ = value;
}
inline void C_SWAP_ITEM::set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_2(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SWAP_ITEM.idx_2)
}

// -------------------------------------------------------------------

// S_SWAP_ITEM

// uint32 idx_1 = 1;
inline void S_SWAP_ITEM::clear_idx_1() {
  idx_1_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SWAP_ITEM::_internal_idx_1() const {
  return idx_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SWAP_ITEM::idx_1() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SWAP_ITEM.idx_1)
  return _internal_idx_1();
}
inline void S_SWAP_ITEM::_internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_1_ = value;
}
inline void S_SWAP_ITEM::set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_1(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SWAP_ITEM.idx_1)
}

// uint32 idx_2 = 2;
inline void S_SWAP_ITEM::clear_idx_2() {
  idx_2_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SWAP_ITEM::_internal_idx_2() const {
  return idx_2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_SWAP_ITEM::idx_2() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SWAP_ITEM.idx_2)
  return _internal_idx_2();
}
inline void S_SWAP_ITEM::_internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_2_ = value;
}
inline void S_SWAP_ITEM::set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_2(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SWAP_ITEM.idx_2)
}

// -------------------------------------------------------------------

// C_USE_ITEM

// uint32 idx = 1;
inline void C_USE_ITEM::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_USE_ITEM::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_USE_ITEM::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USE_ITEM.idx)
  return _internal_idx();
}
inline void C_USE_ITEM::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void C_USE_ITEM::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USE_ITEM.idx)
}

// -------------------------------------------------------------------

// S_USE_ITEM

// uint32 id = 1;
inline void S_USE_ITEM::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_USE_ITEM::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_USE_ITEM::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USE_ITEM.id)
  return _internal_id();
}
inline void S_USE_ITEM::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void S_USE_ITEM::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USE_ITEM.id)
}

// .Protocol.PBItemData equipdata = 2;
inline bool S_USE_ITEM::_internal_has_equipdata() const {
  return this != internal_default_instance() && equipdata_ != nullptr;
}
inline bool S_USE_ITEM::has_equipdata() const {
  return _internal_has_equipdata();
}
inline const ::Protocol::PBItemData& S_USE_ITEM::_internal_equipdata() const {
  const ::Protocol::PBItemData* p = equipdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBItemData&>(
      ::Protocol::_PBItemData_default_instance_);
}
inline const ::Protocol::PBItemData& S_USE_ITEM::equipdata() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USE_ITEM.equipdata)
  return _internal_equipdata();
}
inline void S_USE_ITEM::unsafe_arena_set_allocated_equipdata(
    ::Protocol::PBItemData* equipdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equipdata_);
  }
  equipdata_ = equipdata;
  if (equipdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USE_ITEM.equipdata)
}
inline ::Protocol::PBItemData* S_USE_ITEM::release_equipdata() {
  
  ::Protocol::PBItemData* temp = equipdata_;
  equipdata_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBItemData* S_USE_ITEM::unsafe_arena_release_equipdata() {
  // @@protoc_insertion_point(field_release:Protocol.S_USE_ITEM.equipdata)
  
  ::Protocol::PBItemData* temp = equipdata_;
  equipdata_ = nullptr;
  return temp;
}
inline ::Protocol::PBItemData* S_USE_ITEM::_internal_mutable_equipdata() {
  
  if (equipdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBItemData>(GetArenaForAllocation());
    equipdata_ = p;
  }
  return equipdata_;
}
inline ::Protocol::PBItemData* S_USE_ITEM::mutable_equipdata() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_USE_ITEM.equipdata)
  return _internal_mutable_equipdata();
}
inline void S_USE_ITEM::set_allocated_equipdata(::Protocol::PBItemData* equipdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(equipdata_);
  }
  if (equipdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equipdata));
    if (message_arena != submessage_arena) {
      equipdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equipdata, submessage_arena);
    }
    
  } else {
    
  }
  equipdata_ = equipdata;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USE_ITEM.equipdata)
}

// uint32 invenidx = 3;
inline void S_USE_ITEM::clear_invenidx() {
  invenidx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_USE_ITEM::_internal_invenidx() const {
  return invenidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_USE_ITEM::invenidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USE_ITEM.invenidx)
  return _internal_invenidx();
}
inline void S_USE_ITEM::_internal_set_invenidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  invenidx_ = value;
}
inline void S_USE_ITEM::set_invenidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_invenidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USE_ITEM.invenidx)
}

// .Protocol.PBItemData invendata = 4;
inline bool S_USE_ITEM::_internal_has_invendata() const {
  return this != internal_default_instance() && invendata_ != nullptr;
}
inline bool S_USE_ITEM::has_invendata() const {
  return _internal_has_invendata();
}
inline const ::Protocol::PBItemData& S_USE_ITEM::_internal_invendata() const {
  const ::Protocol::PBItemData* p = invendata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBItemData&>(
      ::Protocol::_PBItemData_default_instance_);
}
inline const ::Protocol::PBItemData& S_USE_ITEM::invendata() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USE_ITEM.invendata)
  return _internal_invendata();
}
inline void S_USE_ITEM::unsafe_arena_set_allocated_invendata(
    ::Protocol::PBItemData* invendata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invendata_);
  }
  invendata_ = invendata;
  if (invendata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USE_ITEM.invendata)
}
inline ::Protocol::PBItemData* S_USE_ITEM::release_invendata() {
  
  ::Protocol::PBItemData* temp = invendata_;
  invendata_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBItemData* S_USE_ITEM::unsafe_arena_release_invendata() {
  // @@protoc_insertion_point(field_release:Protocol.S_USE_ITEM.invendata)
  
  ::Protocol::PBItemData* temp = invendata_;
  invendata_ = nullptr;
  return temp;
}
inline ::Protocol::PBItemData* S_USE_ITEM::_internal_mutable_invendata() {
  
  if (invendata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBItemData>(GetArenaForAllocation());
    invendata_ = p;
  }
  return invendata_;
}
inline ::Protocol::PBItemData* S_USE_ITEM::mutable_invendata() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_USE_ITEM.invendata)
  return _internal_mutable_invendata();
}
inline void S_USE_ITEM::set_allocated_invendata(::Protocol::PBItemData* invendata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invendata_);
  }
  if (invendata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invendata));
    if (message_arena != submessage_arena) {
      invendata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invendata, submessage_arena);
    }
    
  } else {
    
  }
  invendata_ = invendata;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USE_ITEM.invendata)
}

// .Protocol.PBCharacterData chardata = 5;
inline bool S_USE_ITEM::_internal_has_chardata() const {
  return this != internal_default_instance() && chardata_ != nullptr;
}
inline bool S_USE_ITEM::has_chardata() const {
  return _internal_has_chardata();
}
inline const ::Protocol::PBCharacterData& S_USE_ITEM::_internal_chardata() const {
  const ::Protocol::PBCharacterData* p = chardata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PBCharacterData&>(
      ::Protocol::_PBCharacterData_default_instance_);
}
inline const ::Protocol::PBCharacterData& S_USE_ITEM::chardata() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USE_ITEM.chardata)
  return _internal_chardata();
}
inline void S_USE_ITEM::unsafe_arena_set_allocated_chardata(
    ::Protocol::PBCharacterData* chardata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chardata_);
  }
  chardata_ = chardata;
  if (chardata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USE_ITEM.chardata)
}
inline ::Protocol::PBCharacterData* S_USE_ITEM::release_chardata() {
  
  ::Protocol::PBCharacterData* temp = chardata_;
  chardata_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PBCharacterData* S_USE_ITEM::unsafe_arena_release_chardata() {
  // @@protoc_insertion_point(field_release:Protocol.S_USE_ITEM.chardata)
  
  ::Protocol::PBCharacterData* temp = chardata_;
  chardata_ = nullptr;
  return temp;
}
inline ::Protocol::PBCharacterData* S_USE_ITEM::_internal_mutable_chardata() {
  
  if (chardata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PBCharacterData>(GetArenaForAllocation());
    chardata_ = p;
  }
  return chardata_;
}
inline ::Protocol::PBCharacterData* S_USE_ITEM::mutable_chardata() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_USE_ITEM.chardata)
  return _internal_mutable_chardata();
}
inline void S_USE_ITEM::set_allocated_chardata(::Protocol::PBCharacterData* chardata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chardata_);
  }
  if (chardata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chardata));
    if (message_arena != submessage_arena) {
      chardata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chardata, submessage_arena);
    }
    
  } else {
    
  }
  chardata_ = chardata;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USE_ITEM.chardata)
}

// -------------------------------------------------------------------

// S_STAT

// uint32 id = 1;
inline void S_STAT::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_STAT::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_STAT::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.id)
  return _internal_id();
}
inline void S_STAT::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void S_STAT::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.id)
}

// float hp = 2;
inline void S_STAT::clear_hp() {
  hp_ = 0;
}
inline float S_STAT::_internal_hp() const {
  return hp_;
}
inline float S_STAT::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.hp)
  return _internal_hp();
}
inline void S_STAT::_internal_set_hp(float value) {
  
  hp_ = value;
}
inline void S_STAT::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.hp)
}

// float mp = 3;
inline void S_STAT::clear_mp() {
  mp_ = 0;
}
inline float S_STAT::_internal_mp() const {
  return mp_;
}
inline float S_STAT::mp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.mp)
  return _internal_mp();
}
inline void S_STAT::_internal_set_mp(float value) {
  
  mp_ = value;
}
inline void S_STAT::set_mp(float value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.mp)
}

// float exp = 4;
inline void S_STAT::clear_exp() {
  exp_ = 0;
}
inline float S_STAT::_internal_exp() const {
  return exp_;
}
inline float S_STAT::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.exp)
  return _internal_exp();
}
inline void S_STAT::_internal_set_exp(float value) {
  
  exp_ = value;
}
inline void S_STAT::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.exp)
}

// float maxhp = 5;
inline void S_STAT::clear_maxhp() {
  maxhp_ = 0;
}
inline float S_STAT::_internal_maxhp() const {
  return maxhp_;
}
inline float S_STAT::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.maxhp)
  return _internal_maxhp();
}
inline void S_STAT::_internal_set_maxhp(float value) {
  
  maxhp_ = value;
}
inline void S_STAT::set_maxhp(float value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.maxhp)
}

// float maxmp = 6;
inline void S_STAT::clear_maxmp() {
  maxmp_ = 0;
}
inline float S_STAT::_internal_maxmp() const {
  return maxmp_;
}
inline float S_STAT::maxmp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.maxmp)
  return _internal_maxmp();
}
inline void S_STAT::_internal_set_maxmp(float value) {
  
  maxmp_ = value;
}
inline void S_STAT::set_maxmp(float value) {
  _internal_set_maxmp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.maxmp)
}

// float damage = 7;
inline void S_STAT::clear_damage() {
  damage_ = 0;
}
inline float S_STAT::_internal_damage() const {
  return damage_;
}
inline float S_STAT::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STAT.damage)
  return _internal_damage();
}
inline void S_STAT::_internal_set_damage(float value) {
  
  damage_ = value;
}
inline void S_STAT::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STAT.damage)
}

// -------------------------------------------------------------------

// C_STAT

// uint32 id = 1;
inline void C_STAT::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_STAT::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_STAT::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_STAT.id)
  return _internal_id();
}
inline void C_STAT::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void C_STAT::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_STAT.id)
}

// float hp = 2;
inline void C_STAT::clear_hp() {
  hp_ = 0;
}
inline float C_STAT::_internal_hp() const {
  return hp_;
}
inline float C_STAT::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_STAT.hp)
  return _internal_hp();
}
inline void C_STAT::_internal_set_hp(float value) {
  
  hp_ = value;
}
inline void C_STAT::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_STAT.hp)
}

// float mp = 3;
inline void C_STAT::clear_mp() {
  mp_ = 0;
}
inline float C_STAT::_internal_mp() const {
  return mp_;
}
inline float C_STAT::mp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_STAT.mp)
  return _internal_mp();
}
inline void C_STAT::_internal_set_mp(float value) {
  
  mp_ = value;
}
inline void C_STAT::set_mp(float value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_STAT.mp)
}

// float exp = 4;
inline void C_STAT::clear_exp() {
  exp_ = 0;
}
inline float C_STAT::_internal_exp() const {
  return exp_;
}
inline float C_STAT::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_STAT.exp)
  return _internal_exp();
}
inline void C_STAT::_internal_set_exp(float value) {
  
  exp_ = value;
}
inline void C_STAT::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_STAT.exp)
}

// -------------------------------------------------------------------

// S_DEAD

// -------------------------------------------------------------------

// C_RESPAWN

// -------------------------------------------------------------------

// S_RESPAWN

// uint32 idx_1 = 1;
inline void S_RESPAWN::clear_idx_1() {
  idx_1_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_RESPAWN::_internal_idx_1() const {
  return idx_1_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_RESPAWN::idx_1() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RESPAWN.idx_1)
  return _internal_idx_1();
}
inline void S_RESPAWN::_internal_set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_1_ = value;
}
inline void S_RESPAWN::set_idx_1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_1(value);
  // @@protoc_insertion_point(field_set:Protocol.S_RESPAWN.idx_1)
}

// uint32 idx_2 = 2;
inline void S_RESPAWN::clear_idx_2() {
  idx_2_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_RESPAWN::_internal_idx_2() const {
  return idx_2_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_RESPAWN::idx_2() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RESPAWN.idx_2)
  return _internal_idx_2();
}
inline void S_RESPAWN::_internal_set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_2_ = value;
}
inline void S_RESPAWN::set_idx_2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx_2(value);
  // @@protoc_insertion_point(field_set:Protocol.S_RESPAWN.idx_2)
}

// -------------------------------------------------------------------

// C_UNEQUIP

// uint32 idx = 1;
inline void C_UNEQUIP::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_UNEQUIP::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 C_UNEQUIP::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UNEQUIP.idx)
  return _internal_idx();
}
inline void C_UNEQUIP::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void C_UNEQUIP::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UNEQUIP.idx)
}

// -------------------------------------------------------------------

// S_UNEQUIP

// uint32 id = 1;
inline void S_UNEQUIP::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_UNEQUIP::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_UNEQUIP::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UNEQUIP.id)
  return _internal_id();
}
inline void S_UNEQUIP::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void S_UNEQUIP::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UNEQUIP.id)
}

// uint32 idx = 2;
inline void S_UNEQUIP::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_UNEQUIP::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_UNEQUIP::idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UNEQUIP.idx)
  return _internal_idx();
}
inline void S_UNEQUIP::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void S_UNEQUIP::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UNEQUIP.idx)
}

// -------------------------------------------------------------------

// S_EXP

// uint32 level = 1;
inline void S_EXP::clear_level() {
  level_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_EXP::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 S_EXP::level() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EXP.level)
  return _internal_level();
}
inline void S_EXP::_internal_set_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  level_ = value;
}
inline void S_EXP::set_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EXP.level)
}

// float exp = 2;
inline void S_EXP::clear_exp() {
  exp_ = 0;
}
inline float S_EXP::_internal_exp() const {
  return exp_;
}
inline float S_EXP::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EXP.exp)
  return _internal_exp();
}
inline void S_EXP::_internal_set_exp(float value) {
  
  exp_ = value;
}
inline void S_EXP::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EXP.exp)
}

// float maxexp = 3;
inline void S_EXP::clear_maxexp() {
  maxexp_ = 0;
}
inline float S_EXP::_internal_maxexp() const {
  return maxexp_;
}
inline float S_EXP::maxexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EXP.maxexp)
  return _internal_maxexp();
}
inline void S_EXP::_internal_set_maxexp(float value) {
  
  maxexp_ = value;
}
inline void S_EXP::set_maxexp(float value) {
  _internal_set_maxexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EXP.maxexp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
